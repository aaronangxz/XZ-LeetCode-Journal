"use strict";(self.webpackChunkleetcode_notes=self.webpackChunkleetcode_notes||[]).push([[4145],{3905:function(t,o,n){n.d(o,{Zo:function(){return l},kt:function(){return d}});var e=n(7294);function r(t,o,n){return o in t?Object.defineProperty(t,o,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[o]=n,t}function i(t,o){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var e=Object.getOwnPropertySymbols(t);o&&(e=e.filter((function(o){return Object.getOwnPropertyDescriptor(t,o).enumerable}))),n.push.apply(n,e)}return n}function a(t){for(var o=1;o<arguments.length;o++){var n=null!=arguments[o]?arguments[o]:{};o%2?i(Object(n),!0).forEach((function(o){r(t,o,n[o])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(o){Object.defineProperty(t,o,Object.getOwnPropertyDescriptor(n,o))}))}return t}function m(t,o){if(null==t)return{};var n,e,r=function(t,o){if(null==t)return{};var n,e,r={},i=Object.keys(t);for(e=0;e<i.length;e++)n=i[e],o.indexOf(n)>=0||(r[n]=t[n]);return r}(t,o);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(e=0;e<i.length;e++)n=i[e],o.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var u=e.createContext({}),s=function(t){var o=e.useContext(u),n=o;return t&&(n="function"==typeof t?t(o):a(a({},o),t)),n},l=function(t){var o=s(t.components);return e.createElement(u.Provider,{value:o},t.children)},p={inlineCode:"code",wrapper:function(t){var o=t.children;return e.createElement(e.Fragment,{},o)}},c=e.forwardRef((function(t,o){var n=t.components,r=t.mdxType,i=t.originalType,u=t.parentName,l=m(t,["components","mdxType","originalType","parentName"]),c=s(n),d=r,f=c["".concat(u,".").concat(d)]||c[d]||p[d]||i;return n?e.createElement(f,a(a({ref:o},l),{},{components:n})):e.createElement(f,a({ref:o},l))}));function d(t,o){var n=arguments,r=o&&o.mdxType;if("string"==typeof t||r){var i=n.length,a=new Array(i);a[0]=c;var m={};for(var u in o)hasOwnProperty.call(o,u)&&(m[u]=o[u]);m.originalType=t,m.mdxType="string"==typeof t?t:r,a[1]=m;for(var s=2;s<i;s++)a[s]=n[s];return e.createElement.apply(null,a)}return e.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9365:function(t,o,n){n.r(o),n.d(o,{assets:function(){return l},contentTitle:function(){return u},default:function(){return d},frontMatter:function(){return m},metadata:function(){return s},toc:function(){return p}});var e=n(7462),r=n(3366),i=(n(7294),n(3905)),a=["components"],m={sidebar_position:1007},u="[WIP] 1007. Minimum Domino Rotations For Equal Row",s={unversionedId:"tutorial-extras/Minimum Domino Rotations For Equal Row",id:"tutorial-extras/Minimum Domino Rotations For Equal Row",title:"[WIP] 1007. Minimum Domino Rotations For Equal Row",description:"Question",source:"@site/docs/tutorial-extras/1007. Minimum Domino Rotations For Equal Row.md",sourceDirName:"tutorial-extras",slug:"/tutorial-extras/Minimum Domino Rotations For Equal Row",permalink:"/XZ-LeetCode-Journal/docs/tutorial-extras/Minimum Domino Rotations For Equal Row",editUrl:"https://github.com/aaronangxz/XZ-LeetCode-Journal/blob/master/docs/tutorial-extras/1007. Minimum Domino Rotations For Equal Row.md",tags:[],version:"current",sidebarPosition:1007,frontMatter:{sidebar_position:1007},sidebar:"tutorialSidebar",previous:{title:"946. Validate Stack Sequences",permalink:"/XZ-LeetCode-Journal/docs/tutorial-extras/Validate Stack Sequences"},next:{title:"1249. Minimum Remove to Make Valid Parentheses",permalink:"/XZ-LeetCode-Journal/docs/tutorial-extras/Minimum Remove to Make Valid Parentheses"}},l={},p=[{value:"Question",id:"question",level:2},{value:"Approach",id:"approach",level:2},{value:"Solution",id:"solution",level:2}],c={toc:p};function d(t){var o=t.components,n=(0,r.Z)(t,a);return(0,i.kt)("wrapper",(0,e.Z)({},c,n,{components:o,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"wip-1007-minimum-domino-rotations-for-equal-row"},"[WIP]"," 1007. Minimum Domino Rotations For Equal Row"),(0,i.kt)("h2",{id:"question"},"Question"),(0,i.kt)("p",null,"In a row of dominoes, ",(0,i.kt)("inlineCode",{parentName:"p"},"tops[i]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bottoms[i]")," represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)"),(0,i.kt)("p",null,"We may rotate the ",(0,i.kt)("inlineCode",{parentName:"p"},"ith")," domino, so that ",(0,i.kt)("inlineCode",{parentName:"p"},"tops[i]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bottoms[i"),"] swap values."),(0,i.kt)("p",null,"Return the minimum number of rotations so that all the values in tops are the same, or all the values in ",(0,i.kt)("inlineCode",{parentName:"p"},"bottoms")," are the same."),(0,i.kt)("p",null,"If it cannot be done, return ",(0,i.kt)("inlineCode",{parentName:"p"},"-1"),"."),(0,i.kt)("p",null,"Example 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]\nOutput: 2\nExplanation: \nThe first figure represents the dominoes as given by tops and bottoms: before we do any rotations.\nIf we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.\n")),(0,i.kt)("p",null,"Example 2:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]\nOutput: -1\nExplanation: \nIn this case, it is not possible to rotate the dominoes to make one row of values equal.\n")),(0,i.kt)("p",null,"Constraints:\n2 <= tops.length <= 2 * 104\nbottoms.length == tops.length\n1 <= tops","[i]",", bottoms","[i]"," <= 6"),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"approach"},"Approach"),(0,i.kt)("h2",{id:"solution"},"Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class Solution {\npublic:\n    int minDominoRotations(vector<int>& tops, vector<int>& bottoms) {\n        //find rows with most common, and record the common element\n        unordered_map<int,int> topM;\n        unordered_map<int,int> bottomM;\n        int topCommon, bottomCommom;\n        int topCommonCount = 0, bottomCommomCount = 0;\n        int count = 0;\n        \n        for(int i = 0; i < tops.size(); i++){\n            topM[tops[i]]++;\n            if(topM[tops[i]] > topCommonCount){\n                topCommon = tops[i];\n                topCommonCount = topM[tops[i]];\n            } \n        }\n        \n         for(int j = 0; j < bottoms.size(); j++){\n            bottomM[bottoms[j]]++;\n            if(bottomM[bottoms[j]] > bottomCommomCount){\n                bottomCommom = bottoms[j];\n                bottomCommomCount = bottomM[bottoms[j]];\n            } \n        }\n        \n        cout << "topCommon " << topCommon << " count: " << topCommonCount << endl;\n        cout << "bottomCommon " << bottomCommom << " count: " << bottomCommomCount << endl;\n\n        if(topCommonCount >= bottomCommomCount){\n            for(int k = 0; k < tops.size(); k++){\n                if(tops[k] != topCommon){\n                    if(topCommon == bottoms[k]){\n                        count++;\n                    } else{\n                        return -1;\n                    }\n                }\n            }\n        }else {\n            for(int l = 0; l < bottoms.size(); l++){\n                if(bottoms[l] != bottomCommom){\n                    if(bottomCommom == tops[l]){\n                        count++;\n                    } else{\n                        return -1;\n                    }\n                }\n            }\n            \n        }\n        return count;\n    }\n};\n')))}d.isMDXComponent=!0}}]);