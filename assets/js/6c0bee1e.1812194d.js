"use strict";(self.webpackChunkleetcode_notes=self.webpackChunkleetcode_notes||[]).push([[3066],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),h=a,m=d["".concat(s,".").concat(h)]||d[h]||p[h]||i;return n?r.createElement(m,o(o({ref:t},u),{},{components:n})):r.createElement(m,o({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4835:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return p}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],l={sidebar_position:763},s="763. Partition Labels",c={unversionedId:"medium/Partition Labels",id:"medium/Partition Labels",title:"763. Partition Labels",description:"Question",source:"@site/docs/medium/763. Partition Labels.md",sourceDirName:"medium",slug:"/medium/Partition Labels",permalink:"XZ-LeetCode-Journal/docs/medium/Partition Labels",editUrl:"https://github.com/aaronangxz/XZ-LeetCode-Journal/blob/master/docs/medium/763. Partition Labels.md",tags:[],version:"current",sidebarPosition:763,frontMatter:{sidebar_position:763},sidebar:"tutorialSidebar",previous:{title:"[WIP] 316. Remove Duplicate Letters",permalink:"XZ-LeetCode-Journal/docs/medium/Remove Duplicate Letters"},next:{title:"[WIP] 856. Score of Parentheses",permalink:"XZ-LeetCode-Journal/docs/medium/Score of Parentheses"}},u={},p=[{value:"Question",id:"question",level:2},{value:"Approach",id:"approach",level:2},{value:"Solution",id:"solution",level:2}],d={toc:p};function h(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"763-partition-labels"},"763. Partition Labels"),(0,i.kt)("h2",{id:"question"},"Question"),(0,i.kt)("p",null,"You are given a string ",(0,i.kt)("inlineCode",{parentName:"p"},"s"),". We want to partition the string into as many parts as possible so that each letter appears in at most one part."),(0,i.kt)("p",null,"Note that the partition is done so that after concatenating all the parts in order, the resultant string should be ",(0,i.kt)("inlineCode",{parentName:"p"},"s"),"."),(0,i.kt)("p",null,"Return a list of integers representing the size of these parts."),(0,i.kt)("p",null,"Example 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: s = "ababcbacadefegdehijhklij"\nOutput: [9,7,8]\nExplanation:\nThe partition is "ababcbaca", "defegde", "hijhklij".\nThis is a partition so that each letter appears in at most one part.\nA partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits s into less parts.\n')),(0,i.kt)("p",null,"Example 2:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: s = "eccbbbbdec"\nOutput: [10]\n')),(0,i.kt)("p",null,"Constraints:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"1 <= s.length <= 500"),(0,i.kt)("li",{parentName:"ul"},"s consists of lowercase English letters.")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"approach"},"Approach"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Iterate through the string, and save the last occurence index of each characters in a length 26 vector. ",(0,i.kt)("inlineCode",{parentName:"li"},"'a'")," will be in index 0, and so on."),(0,i.kt)("li",{parentName:"ol"},"Iterate the string again, check the last occurence index of the character."),(0,i.kt)("li",{parentName:"ol"},"If the current index is indeed the last occurence, it is the end of partition."),(0,i.kt)("li",{parentName:"ol"},"Push the current index - 1 to result vector."),(0,i.kt)("li",{parentName:"ol"},"Update start so that we know the start index of the next partition.")),(0,i.kt)("h2",{id:"solution"},"Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    vector<int> partitionLabels(string s) {\n        vector<int> end_idx(26,0);\n        \n        for(int i = 0; i < s.length(); ++i)\n            end_idx[s[i] - 'a']  = i;\n        \n        vector<int> res;\n        \n        int start = 0, end = 0;\n        // scanning string character by character\n        for(int i = 0; i < s.length(); ++i)\n        {\n        // whenever we get an character we check,\n        // last index of that character\n            end = max(end, end_idx[s[i] - 'a']);\n            \n            // when current i.e i == end\n            // add it to result\n            if( i == end)\n            {\n                // all the characters of current partition included\n                res.push_back(i - start + 1);\n                // update the start pointer for fresh start\n                start = i + 1;\n            }\n        }\n        \n        return res;\n    }\n};\n")))}h.isMDXComponent=!0}}]);