"use strict";(self.webpackChunkleetcode_notes=self.webpackChunkleetcode_notes||[]).push([[1316],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=r.createContext({}),c=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(u.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},s=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,u=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),s=c(n),d=o,f=s["".concat(u,".").concat(d)]||s[d]||m[d]||i;return n?r.createElement(f,a(a({ref:t},p),{},{components:n})):r.createElement(f,a({ref:t},p))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=s;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l.mdxType="string"==typeof e?e:o,a[1]=l;for(var c=2;c<i;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}s.displayName="MDXCreateElement"},2139:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return u},default:function(){return d},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return m}});var r=n(7462),o=n(3366),i=(n(7294),n(3905)),a=["components"],l={sidebar_position:59},u="59. Spiral Matrix II",c={unversionedId:"leetcode/medium/Spiral Matrix II",id:"leetcode/medium/Spiral Matrix II",title:"59. Spiral Matrix II",description:"Question",source:"@site/docs/leetcode/medium/59. Spiral Matrix II.md",sourceDirName:"leetcode/medium",slug:"/leetcode/medium/Spiral Matrix II",permalink:"/XZ-LeetCode-Journal/docs/leetcode/medium/Spiral Matrix II",tags:[],version:"current",sidebarPosition:59,frontMatter:{sidebar_position:59},sidebar:"lcSidebar",previous:{title:"46. Permutations",permalink:"/XZ-LeetCode-Journal/docs/leetcode/medium/Permutations"},next:{title:"[WIP] 61. Rotate List",permalink:"/XZ-LeetCode-Journal/docs/leetcode/medium/Rotate List"}},p={},m=[{value:"Question",id:"question",level:2},{value:"Approach",id:"approach",level:2},{value:"Solution",id:"solution",level:2}],s={toc:m};function d(e){var t=e.components,n=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"59-spiral-matrix-ii"},"59. Spiral Matrix II"),(0,i.kt)("h2",{id:"question"},"Question"),(0,i.kt)("p",null,"Given a positive integer ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),", generate an ",(0,i.kt)("inlineCode",{parentName:"p"},"n x n")," matrix filled with elements from ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"n^2")," in spiral order."),(0,i.kt)("p",null,"Example 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"1 -> 2 -> 3 \n          |\n8 -> 9    4\n|         |\n7 <- 6 <- 5\n\nInput: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]\n")),(0,i.kt)("p",null,"Example 2:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: n = 1\nOutput: [[1]]\n")),(0,i.kt)("p",null,"Constraints:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"1 <= n <= 20")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"approach"},"Approach"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"By observing the example, we are going to put in incremented values from the outer most of the matrix, and go inwards unti there is no more empty space."),(0,i.kt)("li",{parentName:"ol"},"The boundary for row and column is ",(0,i.kt)("inlineCode",{parentName:"li"},"n-1")," as the furthest cell is ",(0,i.kt)("inlineCode",{parentName:"li"},"[n,n]")),(0,i.kt)("li",{parentName:"ol"},"First, iterate through the top of the matrix."),(0,i.kt)("li",{parentName:"ol"},"Then, the right side of the matrix, from top to bottom with the column fixed. Note that the furthest right cell should already be filled in the previous step, hence start from the next cell under the previous last cell."),(0,i.kt)("li",{parentName:"ol"},"Then, the bottom of the matrix, from right to left with the row fixed. Similarly the right most cell was filled too, hence start from the next right-most cell."),(0,i.kt)("li",{parentName:"ol"},"Then, the left side of the matrix, from bottom to the top and stop right before the first cell that we filled in at the top row."),(0,i.kt)("li",{parentName:"ol"},"The outer layer cells should be all filled by now. We can move both the row and column iterator by 1, and shrink the boundary by 1."),(0,i.kt)("li",{parentName:"ol"},"Repeat until the iterator meets the boundary. ")),(0,i.kt)("h2",{id:"solution"},"Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        int i = 0, j = 0;\n        int count = 0;\n        int maxRow = n - 1, maxCol = n - 1;\n        vector<vector<int>> ans (n, vector<int> (n));\n        \n        while(i <= maxRow && j <= maxCol){\n            //top, move col, fixed row\n            for(int a = j; a <= maxCol; a++){\n                ans[i][a] = ++count;\n            }\n            \n            //right, move row, fixed col\n            for(int b = i + 1; b <= maxRow; b++){\n                ans[b][maxCol] = ++count;\n            }\n            \n            //bottom, move col, fixed row\n            for(int c = maxCol - 1; c >= j; c--){\n                ans[maxRow][c] = ++count;\n            }\n            \n            //left, move row, fixed col\n            for(int d = maxRow - 1; d > i; d--){\n                ans[d][j] = ++count;\n            }\n            \n            i++;\n            j++;\n            maxRow --;\n            maxCol --;\n        }\n        return ans;\n    }\n};\n")))}d.isMDXComponent=!0}}]);