"use strict";(self.webpackChunkleetcode_notes=self.webpackChunkleetcode_notes||[]).push([[2358],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=s(n),d=i,y=p["".concat(c,".").concat(d)]||p[d]||m[d]||a;return n?r.createElement(y,l(l({ref:t},u),{},{components:n})):r.createElement(y,l({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,l=new Array(a);l[0]=p;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var s=2;s<a;s++)l[s]=n[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1521:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return m}});var r=n(7462),i=n(3366),a=(n(7294),n(3905)),l=["components"],o={displayed_sidebar:"notesSideBar"},c="Binary Search",s={unversionedId:"notes/Algorithms/Searching/BinarySearch",id:"notes/Algorithms/Searching/BinarySearch",title:"Binary Search",description:"Binary Search is a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(Log n).",source:"@site/docs/notes/Algorithms/Searching/BinarySearch.md",sourceDirName:"notes/Algorithms/Searching",slug:"/notes/Algorithms/Searching/BinarySearch",permalink:"/XZ-LeetCode-Journal/docs/notes/Algorithms/Searching/BinarySearch",tags:[],version:"current",frontMatter:{displayed_sidebar:"notesSideBar"},sidebar:"notesSideBar",previous:{title:"Hash Functions",permalink:"/XZ-LeetCode-Journal/docs/notes/Algorithms/Hash Functions"},next:{title:"Bubble Sort",permalink:"/XZ-LeetCode-Journal/docs/notes/Algorithms/Sorting/BubbleSort"}},u={},m=[{value:"Implementation",id:"implementation",level:4},{value:"Complexities",id:"complexities",level:3},{value:"Time Complexity",id:"time-complexity",level:4},{value:"Space Complexity",id:"space-complexity",level:4},{value:"Calculating middle element",id:"calculating-middle-element",level:4}],p={toc:m};function d(e){var t=e.components,n=(0,i.Z)(e,l);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"binary-search"},"Binary Search"),(0,a.kt)("p",null,"Binary Search is a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(Log n). "),(0,a.kt)("h4",{id:"implementation"},"Implementation"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"func binarySearchRecursive(array []int, l int, r int, target int) int{\n    //Only if right is greater equal to left\n    if(r >= l){\n        mid := l + (r - l) / 2\n        //found target\n        if array[mid] == target{\n            return mid\n        }\n        //target is in lower half\n        if array[mid] > target{\n            return binarySearchRecursive(array,l,mid-1,target)\n        }\n        //else target must be in upper half\n        return binarySearchRecursive(array,mid + 1,r,target)\n    }\n    //else target is not in array\n    return -1\n}\n\nfunc binarySearchIterative(array []int, l int, r int, target int) int{\n    for l <= r{\n        mid := l + (r - l) / 2\n\n        if array[mid] == target{\n            return mid\n        }    \n\n        if array[mid] > target{\n            r = mid - 1\n        }else{\n            l = mid + 1\n        }\n    }\n    return -1\n}\n\nfunc main(){\n    a := []int{1,5,8,22,55,99,123,456,890,999}\n    //find 456\n    result1 := binarySearchRecursive(a,0,len(a)-1,456)\n    fmt.Println(result1)\n    result2 := binarySearchIterative(a,0,len(a)-1,456)\n    fmt.Println(result2)\n        \n    b := []int{1,5,8,22,55,99,123,456,890,999}\n    //find 1000\n    result3 := binarySearchRecursive(b,0,len(b)-1,1000)\n    fmt.Println(result3)\n    result4 := binarySearchIterative(b,0,len(b)-1,1000)\n    fmt.Println(result4)\n}\n")),(0,a.kt)("h3",{id:"complexities"},"Complexities"),(0,a.kt)("h4",{id:"time-complexity"},"Time Complexity"),(0,a.kt)("p",null,"O(1) When element is in the middle"),(0,a.kt)("p",null,"O(logN) On average"),(0,a.kt)("p",null,"O(logN) Worst case"),(0,a.kt)("h4",{id:"space-complexity"},"Space Complexity"),(0,a.kt)("p",null,"Recursive: O(logN) "),(0,a.kt)("p",null,"Iterative: O(1)"),(0,a.kt)("h4",{id:"calculating-middle-element"},"Calculating middle element"),(0,a.kt)("p",null,"Note that we cannot simply calculate the middle element as:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"mid := (l + r) / 2\n")),(0,a.kt)("p",null,"Because there is a risk that ",(0,a.kt)("inlineCode",{parentName:"p"},"mid")," will overflow in value.\nHence,"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"mid := l + (r - l) / 2\n")))}d.isMDXComponent=!0}}]);