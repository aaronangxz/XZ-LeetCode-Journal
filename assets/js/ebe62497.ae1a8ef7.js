"use strict";(self.webpackChunkleetcode_notes=self.webpackChunkleetcode_notes||[]).push([[6921],{4291:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"/2022/06/17/how-long-is-a-second","metadata":{"permalink":"/XZ-LeetCode-Journal/blog/2022/06/17/how-long-is-a-second","editUrl":"https://github.com/aaronangxz/XZ-LeetCode-Journal/blob/sol-deploy/blog/2022-06-17-how-long-is-a-second.mdx","source":"@site/blog/2022-06-17-how-long-is-a-second.mdx","title":"How long is a second?","description":"Introduction","date":"2022-06-17T00:00:00.000Z","formattedDate":"June 17, 2022","tags":[{"label":"projects","permalink":"/XZ-LeetCode-Journal/blog/tags/projects"},{"label":"go","permalink":"/XZ-LeetCode-Journal/blog/tags/go"}],"readingTime":0.675,"truncated":true,"authors":[{"name":"Ang Xuan Ze","title":"Noob coder","url":"https://github.com/aaronangxz","imageURL":"https://github.com/aaronangxz.png","key":"xuanze"}],"frontMatter":{"title":"How long is a second?","authors":["xuanze"],"tags":["projects","go"]},"nextItem":{"title":"Redis SET or HASH","permalink":"/XZ-LeetCode-Journal/blog/2022/06/17/redis-set-or-hash"}},"content":"## Introduction\\nWhat the hell am I talking about? You might say. Well yea it sounded crazy but **how long is a second** exactly?!\\n\\n## What Happened\\nAs I was writing some unit tests for my shiny Redis Set implementation, somethign weird caught my attention.\\n```\\nTestSendPotentialUsers | Successful | Written 80687641:-18230398344540846 to potential_user set\\n```\\n# *Excuse me?*\\n\\n\x3c!--truncate--\x3e\\n\\n\\nFor context, the Redis key was constructed using:\\n```go\\ntoWrite := fmt.Sprint(u, \\":\\", time.Now().Unix()-common.ONE_MONTH-common.ONE_DAY)\\n```\\n\\nAfter some digging around, I realised that in my `common.ONE_HOUR`:\\n![PascalTriangleAnimated](./static/how-long-is-a-second.png)\\n\\nWhy didn\'t I think of that, it is in milliseconds!\\nAnd my `common.ONE_MONTH-common.ONE_DAY` will effectively become 18144000000000000 - 6048000000000000 \ud83e\udd23\\n\\nOne quick fix is:\\n```go\\n\\tONE_HOUR  = int64(60*time.Minute) / int64(1*time.Second)\\n```\\nAnd noice, it finally makese sense now.\\n```\\nTestSendPotentialUsers | Successful | Written 93737927:1637229666 to potential_user set\\n```"},{"id":"/2022/06/17/redis-set-or-hash","metadata":{"permalink":"/XZ-LeetCode-Journal/blog/2022/06/17/redis-set-or-hash","editUrl":"https://github.com/aaronangxz/XZ-LeetCode-Journal/blob/sol-deploy/blog/2022-06-17-redis-set-or-hash.mdx","source":"@site/blog/2022-06-17-redis-set-or-hash.mdx","title":"Redis SET or HASH","description":"Introduction","date":"2022-06-17T00:00:00.000Z","formattedDate":"June 17, 2022","tags":[{"label":"projects","permalink":"/XZ-LeetCode-Journal/blog/tags/projects"},{"label":"redis","permalink":"/XZ-LeetCode-Journal/blog/tags/redis"}],"readingTime":3.49,"truncated":true,"authors":[{"name":"Ang Xuan Ze","title":"Noob coder","url":"https://github.com/aaronangxz","imageURL":"https://github.com/aaronangxz.png","key":"xuanze"}],"frontMatter":{"title":"Redis SET or HASH","authors":["xuanze"],"tags":["projects","redis"]},"prevItem":{"title":"How long is a second?","permalink":"/XZ-LeetCode-Journal/blog/2022/06/17/how-long-is-a-second"}},"content":"## Introduction\\nSo I was working on [SeaHungerGamesBot](https://github.com/aaronangxz/SeaDinner), \\nand one major pain point was: when a certain user started the conversation, but did not proceed from there. (probably due to the hassle of copy-pasting the API key?)\\n\\nSince my current goal is to have as many active users as possible, that was a wasted opportunity. \\nSo my objective was to keep track of the users that started pressing some commands, but backed off and disappear afterwards. \\nI call them the `potential users`.\\n\\n\x3c!--truncate--\x3e\\n\\n## What\'s the Plan\\nThe initial plan is:\\n\\n```\\nRemind users to use the Bot if:\\n- They have chatted with it before \\n- It happened in the past month\\n- They still did not provide their key in the past month\\n```\\n\\n- For such users, store their `user_id` and the time they call the commands. \\nThis can be achieved easily since all `anonymous users` (aka. those that did not provide their keys) will get routed through\\na `CheckKey` function, and if it does not exist in DB, they will be urged to provide their key in the next step in order to proceed with other features.\\n\\n- The reason we store the `time` is because we want to have a \\"cool down\\" period before we annoy them again. E.g. A user chatted on 1st Jan, \\nwe will not send him the cold message until at least 1st Feb.\\n\\n- If we did send him on 1st Feb, we reset the time to 1st Feb and the next message will be sent on 1st March. So on and so forth.\\n\\n- And if the user provide their key between 1st Feb and 1st March, we remove them from the pool and they will not receive this anymore.\\n\\n## Cool, Now What?\\n\\n### Technical Implementation\\n\\n### 1. Naive\\nThe naive solution is to have a cache key, something like `potential_user:<user_id>` with the value as `time`. Since it is pretty straight forward, and we can `GET` \\nor `SET` the value easily.\\n\\n**Pros**\\n- Easy peasy\\n\\n**Cons**\\n- Kinda messy\\n\\n### 2. Slightly more elegant?\\nThen I thought of Redis Sets, and it is kinda what I prefer it to be. We can have a set called `potential_user`, and inside the set, we have list of keys `<user_id>:<time>`.\\n\\n**Pros**\\n- Very organized, i love it\\n\\n**Cons**\\n- Need to store all the information in the `key`, hence delimiter is needed.\\n- Have to parse the key to get the relevant information.\\n- Since they are not key-value pairs, in order to update the `time`, we have to `SREM` the old key and `SADD` new one afterwards.\\n\\n### 3. Most recommended?\\nI read up on `HASH`, and it seems pretty decent (overkill maybe?) for this use case. And probably a refactor is neede to make it clean.\\n\\nThe key can be just `<user_id>`, and contains field such as `<user_key>` (since we cache the keys to minimize DB calls), `<time>` etc.\\n\\n**Pros**\\n- Treat it as an object, and we do not need any extra keys anymore\\n\\n**Cons**\\n- When we need to find user that has `time` (not everyone will have this field), we have to probably check one by one.\\n\\n## So..\\n\\nI went with option 2, and implement a set. Only thing that I don\'t really like is the update part.\\nNeed to remove first -> then re-write the updated time.\\n\\n```go\\n//Remove the old key and update with the new time in Set\\n//As long as users do not give us the key, they will always be in the pool\\n//We continuously update the time after each cold message to avoid annoyance\\nif err := processors.RedisClient.SRem(common.POTENTIAL_USER_SET, pair).Err(); err != nil {\\n\\tlog.Error(ctx, \\"SendPotentialUsers | Error while writing to redis: %v\\", err.Error())\\n} else {\\n\\tlog.Info(ctx, \\"SendPotentialUsers | Successful | Removed %v from potential_user set\\", pair)\\n}\\n\\ntoWrite := fmt.Sprint(userID, \\":\\", time.Now().Unix())\\nif err := processors.RedisClient.SAdd(common.POTENTIAL_USER_SET, toWrite).Err(); err != nil {\\n\\tlog.Error(ctx, \\"SendPotentialUsers | Error while writing to redis: %v\\", err.Error())\\n} else {\\n\\tlog.Info(ctx, \\"SendPotentialUsers | Successful | Written %v to potential_user set\\", toWrite)\\n}\\n```\\n\\nI guess I will leave it as it is for now, until I can think of a better solution."}]}')}}]);