"use strict";(self.webpackChunkleetcode_notes=self.webpackChunkleetcode_notes||[]).push([[2591],{3905:function(t,o,n){n.d(o,{Zo:function(){return l},kt:function(){return d}});var e=n(7294);function i(t,o,n){return o in t?Object.defineProperty(t,o,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[o]=n,t}function r(t,o){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var e=Object.getOwnPropertySymbols(t);o&&(e=e.filter((function(o){return Object.getOwnPropertyDescriptor(t,o).enumerable}))),n.push.apply(n,e)}return n}function m(t){for(var o=1;o<arguments.length;o++){var n=null!=arguments[o]?arguments[o]:{};o%2?r(Object(n),!0).forEach((function(o){i(t,o,n[o])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(o){Object.defineProperty(t,o,Object.getOwnPropertyDescriptor(n,o))}))}return t}function a(t,o){if(null==t)return{};var n,e,i=function(t,o){if(null==t)return{};var n,e,i={},r=Object.keys(t);for(e=0;e<r.length;e++)n=r[e],o.indexOf(n)>=0||(i[n]=t[n]);return i}(t,o);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(e=0;e<r.length;e++)n=r[e],o.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(i[n]=t[n])}return i}var u=e.createContext({}),s=function(t){var o=e.useContext(u),n=o;return t&&(n="function"==typeof t?t(o):m(m({},o),t)),n},l=function(t){var o=s(t.components);return e.createElement(u.Provider,{value:o},t.children)},p={inlineCode:"code",wrapper:function(t){var o=t.children;return e.createElement(e.Fragment,{},o)}},c=e.forwardRef((function(t,o){var n=t.components,i=t.mdxType,r=t.originalType,u=t.parentName,l=a(t,["components","mdxType","originalType","parentName"]),c=s(n),d=i,f=c["".concat(u,".").concat(d)]||c[d]||p[d]||r;return n?e.createElement(f,m(m({ref:o},l),{},{components:n})):e.createElement(f,m({ref:o},l))}));function d(t,o){var n=arguments,i=o&&o.mdxType;if("string"==typeof t||i){var r=n.length,m=new Array(r);m[0]=c;var a={};for(var u in o)hasOwnProperty.call(o,u)&&(a[u]=o[u]);a.originalType=t,a.mdxType="string"==typeof t?t:i,m[1]=a;for(var s=2;s<r;s++)m[s]=n[s];return e.createElement.apply(null,m)}return e.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9709:function(t,o,n){n.r(o),n.d(o,{assets:function(){return l},contentTitle:function(){return u},default:function(){return d},frontMatter:function(){return a},metadata:function(){return s},toc:function(){return p}});var e=n(7462),i=n(3366),r=(n(7294),n(3905)),m=["components"],a={sidebar_position:1007},u="[WIP] 1007. Minimum Domino Rotations For Equal Row",s={unversionedId:"medium/Minimum Domino Rotations For Equal Row",id:"medium/Minimum Domino Rotations For Equal Row",title:"[WIP] 1007. Minimum Domino Rotations For Equal Row",description:"Question",source:"@site/docs/medium/1007. Minimum Domino Rotations For Equal Row.md",sourceDirName:"medium",slug:"/medium/Minimum Domino Rotations For Equal Row",permalink:"/docs/medium/Minimum Domino Rotations For Equal Row",editUrl:"https://github.com/aaronangxz/XZ-LeetCode-Journal/blob/master/docs/medium/1007. Minimum Domino Rotations For Equal Row.md",tags:[],version:"current",sidebarPosition:1007,frontMatter:{sidebar_position:1007},sidebar:"tutorialSidebar",previous:{title:"946. Validate Stack Sequences",permalink:"/docs/medium/Validate Stack Sequences"},next:{title:"1249. Minimum Remove to Make Valid Parentheses",permalink:"/docs/medium/Minimum Remove to Make Valid Parentheses"}},l={},p=[{value:"Question",id:"question",level:2},{value:"Approach",id:"approach",level:2},{value:"Solution",id:"solution",level:2}],c={toc:p};function d(t){var o=t.components,n=(0,i.Z)(t,m);return(0,r.kt)("wrapper",(0,e.Z)({},c,n,{components:o,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"wip-1007-minimum-domino-rotations-for-equal-row"},"[WIP]"," 1007. Minimum Domino Rotations For Equal Row"),(0,r.kt)("h2",{id:"question"},"Question"),(0,r.kt)("p",null,"In a row of dominoes, ",(0,r.kt)("inlineCode",{parentName:"p"},"tops[i]")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"bottoms[i]")," represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)"),(0,r.kt)("p",null,"We may rotate the ",(0,r.kt)("inlineCode",{parentName:"p"},"ith")," domino, so that ",(0,r.kt)("inlineCode",{parentName:"p"},"tops[i]")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"bottoms[i"),"] swap values."),(0,r.kt)("p",null,"Return the minimum number of rotations so that all the values in tops are the same, or all the values in ",(0,r.kt)("inlineCode",{parentName:"p"},"bottoms")," are the same."),(0,r.kt)("p",null,"If it cannot be done, return ",(0,r.kt)("inlineCode",{parentName:"p"},"-1"),"."),(0,r.kt)("p",null,"Example 1:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]\nOutput: 2\nExplanation: \nThe first figure represents the dominoes as given by tops and bottoms: before we do any rotations.\nIf we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.\n")),(0,r.kt)("p",null,"Example 2:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]\nOutput: -1\nExplanation: \nIn this case, it is not possible to rotate the dominoes to make one row of values equal.\n")),(0,r.kt)("p",null,"Constraints:\n2 <= tops.length <= 2 * 104\nbottoms.length == tops.length\n1 <= tops","[i]",", bottoms","[i]"," <= 6"),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"approach"},"Approach"),(0,r.kt)("h2",{id:"solution"},"Solution"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class Solution {\npublic:\n    int minDominoRotations(vector<int>& tops, vector<int>& bottoms) {\n        //find rows with most common, and record the common element\n        unordered_map<int,int> topM;\n        unordered_map<int,int> bottomM;\n        int topCommon, bottomCommom;\n        int topCommonCount = 0, bottomCommomCount = 0;\n        int count = 0;\n        \n        for(int i = 0; i < tops.size(); i++){\n            topM[tops[i]]++;\n            if(topM[tops[i]] > topCommonCount){\n                topCommon = tops[i];\n                topCommonCount = topM[tops[i]];\n            } \n        }\n        \n         for(int j = 0; j < bottoms.size(); j++){\n            bottomM[bottoms[j]]++;\n            if(bottomM[bottoms[j]] > bottomCommomCount){\n                bottomCommom = bottoms[j];\n                bottomCommomCount = bottomM[bottoms[j]];\n            } \n        }\n        \n        cout << "topCommon " << topCommon << " count: " << topCommonCount << endl;\n        cout << "bottomCommon " << bottomCommom << " count: " << bottomCommomCount << endl;\n\n        if(topCommonCount >= bottomCommomCount){\n            for(int k = 0; k < tops.size(); k++){\n                if(tops[k] != topCommon){\n                    if(topCommon == bottoms[k]){\n                        count++;\n                    } else{\n                        return -1;\n                    }\n                }\n            }\n        }else {\n            for(int l = 0; l < bottoms.size(); l++){\n                if(bottoms[l] != bottomCommom){\n                    if(bottomCommom == tops[l]){\n                        count++;\n                    } else{\n                        return -1;\n                    }\n                }\n            }\n            \n        }\n        return count;\n    }\n};\n')))}d.isMDXComponent=!0}}]);